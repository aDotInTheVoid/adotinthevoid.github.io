<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>  Rustdoc JSON in 2023  ❧ Alona Enraght-Moony   </title>
    <link rel="icon" href="/pfp-32.png" type="image/png">
    <link rel="stylesheet" href="/style.css">
    <link href="https://alona.page/index.xml" rel="alternate" type="application/rss+xml"
        title="Alona Enraght-Moony" />
</head>

<body>
    



<a href="/">Home</a>

<h1>Rustdoc JSON in 2023</h1>
<p>31 December 2023</p>

<p>It’s been another year again, and folks <a href="https://bytecodealliance.org/articles/wasmtime-and-cranelift-in-2023">are</a> <a href="https://slint.dev/blog/2023-in-review">writing</a> <a href="https://www.eff.org/deeplinks/2023/12/fighting-european-threats-encryption-2023-year-review">about</a> <a href="https://wordpress.com/blog/2023/12/29/2023-year-in-review/">what</a> <a href="https://blog.thea.codes/my-2023/">happened</a> on their project this year,
and looking forward to next year. I did this <a href="/posts/rustdoc-json-2022/">last year</a>, and it was a super useful exercise for me
personally, and also a good resource of what’s changed, without having to trawl through GitHub.</p>
<h2><a id="what" class="anchor" href="#what" aria-hidden="true"></a>What’s Rustdoc JSON</h2>
<p>(note: You can skip this section if you’re already familiar with it.)</p>
<p>Rustdoc JSON is a unstable feature for rustdoc that allows generating machine readable JSON output describing
the API of a crate (instead of the normal human readable HTML output). If you think of rustdoc like a compiler
from a crate to a description of its API <sup class="footnote-reference" id="fnref:1"><a href="#fn:1">1</a></sup>, this is an alternative target.</p>
<p>This allows tools to reason mechanically about an API in rust. It’s the underlying data source for
<a href="https://roogle.hkmatsumoto.com/">roogle</a>,
<a href="https://github.com/awslabs/cargo-check-external-types">cargo-check-external-types</a>,
<a href="https://github.com/LukeMathWalker/pavex/">pavex</a>,
and many more.</p>
<h2><a id="format-changes" class="anchor" href="#format-changes" aria-hidden="true"></a>Format Changes</h2>
<p>The most user-facing changes this year were changes to the JSON format itself. We made 5 of them:</p>
<ol start="24">
<li><a href="https://github.com/rust-lang/rust/pull/106354">#106354</a>: <code>Variant</code> was split into <code>Variant</code> and <code>VariantKind</code>, so the enum discriminant can always be reported. Previously, it could only be reported for a plain enum variant (i.e. one with no fields or braces).</li>
<li><a href="https://github.com/rust-lang/rust/pull/109410">#109410</a>: Support inherent associated types.</li>
<li><a href="https://github.com/rust-lang/rust/pull/111427">#111427</a>: Serialize all enums using external tagging. This changed the JSON representation of the data, but it’s the same after deserialization into rust values. Doing this is more consistent <sup class="footnote-reference" id="fnref:2"><a href="#fn:2">2</a></sup>, and allows (de)serializing to non-self-describing formats, such as postcard and bincode<sup class="footnote-reference" id="fnref:3"><a href="#fn:3">3</a></sup>. This can give a <a href="https://rust-lang.zulipchat.com/#narrow/stream/266220-t-rustdoc/topic/.28De.29serialization.20speed.20of.20JSON.20docs/near/356983259">significant performance improvement</a>. Special thanks to <a href="https://www.lpalmieri.com/">Luca Palmieri</a> for the heroics in landing this, as it required changing every file in the test suite.</li>
<li><a href="https://github.com/rust-lang/rust/pull/115078">#115078</a>: Rename <code>Typedef</code> to <code>TypeAlias</code> to be more in line with standard terminology.</li>
<li><a href="https://github.com/rust-lang/rust/pull/119246">#119246</a>: Add <code>is_object_safe</code> field to <code>Trait</code>.</li>
</ol>
<p>That makes this year significantly more stable than <a href="https://alona.page/posts/rustdoc-json-2022/#format-changes">last
year</a>, where we
changed the format 13 times.</p>
<h2><a id="rustdoc-types-release-scare-and-ownership-transfer" class="anchor" href="#rustdoc-types-release-scare-and-ownership-transfer" aria-hidden="true"></a>rustdoc-types release scare, and ownership transfer.</h2>
<p>On the opposite end of the spectrum, the changes to the <code>rustdoc-types</code> crate shouldn’t be user-visible at all
(touch wood), but are no less important for the long-term health of the project.</p>
<p>The canonical, upstream definition of the rustdoc-json format lives in
<a href="https://github.com/rust-lang/rust/tree/5a345b325b59370171d9a00c8f575fb177ead767/src/rustdoc-json-types">src/rustdoc-json-types/</a>
of the rust repo. It’s used as a dependency by <code>librustdoc</code>, and some in-tree
test tooling. However, it can’t be directly used by 3rd party code, as it isn’t packaged here at all.</p>
<p>To ease adoption, I created the
<a href="https://crates.io/crates/rustdoc-types"><code>rustdoc-types</code></a> crate. It’s a
somewhat automated repackaging of the in-tree <code>rustdoc-json-types</code> crate onto
crates.io. Most consumers (AFAICT) of rustdoc-json do so via this crate.
However, despite its importance, it’s a personal project. It lives in
<a href="https://github.com/aDotInTheVoid/rustdoc-types/tree/4be3505d55aa502f7aec3f71383a7dec660bd177/">my github account</a>,
and only I have the permissions to publish new versions to crates.io.</p>
<p>This is mostly transparent to users, who <a href="https://youtu.be/OxQYyg_v3rw?t=991">can think of</a>
<code>rustdoc-types</code> as being the same as canonical in-tree representation of the format. However,
this relies on the shell script being run to update and publish the crate. Normally
this isn’t a problem, as I tend to review all the changes to rustdoc-json, and am 
<a href="https://github.com/rust-lang/rust/blob/5a345b325b59370171d9a00c8f575fb177ead767/triagebot.toml#L533">automatically pinged</a> when someone
makes a PR changing it.</p>
<p>However, we risked breaking this illusion with <a href="https://github.com/rust-lang/rust/pull/115078">#115078</a>. It got into the merge queue the
night before I was about to leave for a week long camping trip. If it’d been merged while I
was in a field with no internet, a new version of <code>rustdoc-types</code> wouldn’t be
published, and users would be broken. Fortunately for us, the bors queue was quick that
night, so I could publish the new version in morning, just before I left. However this was
a close call, and no-one’s eager for it to happen again.</p>
<p>After some <a href="https://rust-lang.zulipchat.com/#narrow/stream/266220-t-rustdoc/topic/call.20for.20rustdoc-types.20maintainers">discussion on
Zulip</a>,
we decided the right thing to do would be to make <code>rustdoc-types</code> owned by the
Rustdoc Team (instead of me personally). This means that someone else would be
able to make releases if I can’t for whatever reason. It also provides
succession planning for when I inevitably stop working on rust at some point.</p>
<p>To do this, I’ve written and opened <a href="https://github.com/rust-lang/rfcs/pull/3505">an
RFC</a>, which contains motivation, as
well as the logistical details of the ownership transfer. Once this gets
merged, and the crate gets moved, we shouldn’t have to worry about this
happening again.</p>
<h2><a id="good-chats-on-zulip" class="anchor" href="#good-chats-on-zulip" aria-hidden="true"></a>Good Chats on Zulip</h2>
<p>This section is half so you can see how the sausage gets made with designing
stuff, and half so I can find these links easier in the future.</p>
<h3><a id="the-metaformat-and-documenting-signatures-that-rely-on-nightly-features" class="anchor" href="#the-metaformat-and-documenting-signatures-that-rely-on-nightly-features" aria-hidden="true"></a>The Metaformat, and documenting signatures that rely on nightly features</h3>
<p><a href="https://rust-lang.zulipchat.com/#narrow/stream/266220-t-rustdoc/topic/Rustdoc.20JSON.3A.20Experimental.20rustc.20features">Link</a>.
The core question here is “How much support should rustdoc JSON give to nightly language features”, and “How should they be versioned”.
The conclusion is that for now, we should version them like regular language features (to keep <code>format_version</code> as an unambiguous description of which schema was used to serialize).</p>
<p>The main idea that came out of this was the idea of the “metaformat”. Rustdoc JSON
has had a number of different formats over the years, but the way they were
versioned and released has been the same. The idea here is that in addition to
thinking about the format we stabilize, we should also think how we can change the format
after stabilization. The metaformat refers to the design of a series of formats that use
the same mechanism for communicating changes <sup class="footnote-reference" id="fnref:4"><a href="#fn:4">4</a></sup>.</p>
<p>The conclusion is that the existing metaformat is fine for now, but probably not
suitable for stabilization. </p>
<p>Changing the metaformat is much more disruptive to the ecosystem than changing the format.
This is because existing tools rely on the metaformat to
<a href="https://github.com/awslabs/cargo-check-external-types/blob/4bbf5a80fced7e11fdf855537b4202e225596f67/src/cargo.rs#L88-L101">detect if they’re using the correct format</a>
and even
<a href="https://github.com/obi1kenobi/trustfall-rustdoc/blob/a9d7739b848d6bfc05f50ad7c179faec38e18144/src/parser.rs#L43-L70">support multiple format versions at once</a>.
Therefore, we can be quite free to change the format, as the ecosystem is used to it,
and has mechanisms to minimize disruption. But a metaformat change would break all these
mechanisms, and would be much more unexpected.
Therefore, we should aim to only change metaformat once,
and to a metaformat that we believe we can stabilize.</p>
<h3><a id="stabilization-requirements" class="anchor" href="#stabilization-requirements" aria-hidden="true"></a>Stabilization Requirements</h3>
<p>We also talked a 
<a href="https://rust-lang.zulipchat.com/#narrow/stream/266220-rustdoc/topic/Rustdoc.20JSON.3A.20Stabilization.20criteria">couple</a>
of
<a href="https://rust-lang.zulipchat.com/#narrow/stream/266220-t-rustdoc/topic/Long.20Term.20Rustdoc.20JSON.20Stability/near/386100109">times</a>
<sup class="footnote-reference" id="fnref:5"><a href="#fn:5">5</a></sup>
about the path to stabilization. The core blockers are</p>
<ol>
<li>Long term metaformat, that allows adding new language concepts (that don’t exist yet) without breaking users.
<ul>
<li>Also involved in this: How to deal with nightly only language items.</li>
</ul>
</li>
<li>Reliable cross-crate ID lookup. (See the first part of <a href="https://github.com/rust-lang/rust/issues/106697">this issue</a>) for details.</li>
<li>Move <code>rustdoc-types</code> into T-Rustdoc ownership.</li>
<li>Ensure everything’s fully documented.</li>
<li>Ensure <code>core</code> (and popular crates) produces correct output under <code>jsondoclint</code> <sup class="footnote-reference" id="fnref:6"><a href="#fn:6">6</a></sup></li>
</ol>
<p>The first two will require significant design work. The rest is clearer on how to do them, but may well also
throw wrench into the works. I don’t want to speculate on a timeline, but I’d not hold my breath on all this getting done in
anything less than ~2 years.</p>
<h3><a id="cargo-semver-checkstrustfall-test-suite" class="anchor" href="#cargo-semver-checkstrustfall-test-suite" aria-hidden="true"></a>cargo-semver-checks/trustfall Test Suite</h3>
<p>Rustdoc JSON has a test suite that’s built using <a href="https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html">JSONPath</a>
to write assertions about the contents of the JSON.
<a href="https://rust-lang.zulipchat.com/#narrow/stream/266220-t-rustdoc/topic/.E2.9C.94.20Using.20cargo-semver-checks.20in.20rustdoc.20JSON.20tests.3A.20revisited">Someone was wondering</a>
if it made sense to complement this with <a href="https://github.com/obi1kenobi/trustfall">trustfall</a> driven tests, potentially based on the cargo-semver-checks or trustfall-rustdoc-adaptor suites.</p>
<p>We concluded that this wouldn’t be a good idea, as it would require all format
changes to also rewrite the trustfall code, which would add a significant
barrier. In addition, the higher-level invariant checks (that can be run on
every document, IE not asserts for specific items presence) can already be
written inside of <code>jsondoclint</code>, which is much simpler to understand and modify.</p>
<h2><a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"></a>Conclusion</h2>
<p>??? IDK ???. Some stuff happened in 2023. Some of it was Rustdoc JSON related.
Does this post even need a conclusion? Probably.</p>
<p>If you have questions or comments on this post, I’d love to here them.
You can reply to me <a href="https://social.treehouse.systems/@aDot/111675587239258225">on the Fediverse</a>,
open a discussion on <a href="https://github.com/aDotInTheVoid/aDotInTheVoid.github.io/discussions">GitHub</a>,
or send me an <a href="mailto:contact@alona.page">email</a></p>
<p><em>Thanks to <a href="https://jyn.dev/">jyn</a> and <a href="https://predr.ag/">Predrag</a> for their feedback on drafts of this post. Any and all mistakes are solely my own.</em></p>
<hr/><ol><li id="fn:1"><p>I find this is the most helpful way to think about
rustdoc. It’s an alternative backend for rustc, albeit one that forks off
much earlier in the compilation pipeline, and doesn’t produce
executables/libraries.<a href="#fnref:1" class="footnote-backref">↩</a></p>
</li>
<li id="fn:2"><p>Previously we had an ad-hoc mix of <a href="https://github.com/rust-lang/rust/issues/93667">3 different</a> ways of serializing enums to JSON.<a href="#fnref:2" class="footnote-backref">↩</a></p>
</li>
<li id="fn:3"><p>To be clear, their are no plans for rustdoc itself to emit a binary format. However, it allows 3rd party tools to easily convert the JSON to some other format, that they themselves can load.<a href="#fnref:3" class="footnote-backref">↩</a></p>
</li>
<li id="fn:4"><p>That would make the current (and only so far) metaformat be “we have a field called <code>format_version</code> as the root of the JSON object, that is incremented on every change”.<a href="#fnref:4" class="footnote-backref">↩</a></p>
</li>
<li id="fn:5"><p>This latter one was in 2022, but it’s still relevant today, so cut me some slack.<a href="#fnref:5" class="footnote-backref">↩</a></p>
</li>
<li id="fn:6"><p>A testing tool to find dangling ID’s and other invalid output in Rustdoc JSON output.<a href="#fnref:6" class="footnote-backref">↩</a></p>
</li>

</ol>









    <hr />
    <a href="https://github.com/aDotInTheVoid/">GitHub</a>
    <a rel="me" href="https://hachyderm.io/@adotinthevoid">Mastodon</a>
    <a href="mailto:contact@alona.page">Email</a>
    <a href="/index.xml">RSS</a>
</body>

</html>